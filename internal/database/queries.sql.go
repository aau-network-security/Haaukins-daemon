// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addEvent = `-- name: AddEvent :exec
INSERT INTO event (tag, name, available, capacity, frontends, status, exercises, started_at, finish_expected, finished_at, createdby, onlyvpn,secretKey, disabledExercises) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10,$11,$12,$13,$14)
`

type AddEventParams struct {
	Tag               string        `json:"tag"`
	Name              string        `json:"name"`
	Available         int32         `json:"available"`
	Capacity          int32         `json:"capacity"`
	Frontends         string        `json:"frontends"`
	Status            sql.NullInt32 `json:"status"`
	Exercises         string        `json:"exercises"`
	StartedAt         time.Time     `json:"started_at"`
	FinishExpected    time.Time     `json:"finish_expected"`
	FinishedAt        time.Time     `json:"finished_at"`
	Createdby         string        `json:"createdby"`
	Onlyvpn           sql.NullInt32 `json:"onlyvpn"`
	Secretkey         string        `json:"secretkey"`
	Disabledexercises string        `json:"disabledexercises"`
}

func (q *Queries) AddEvent(ctx context.Context, arg AddEventParams) error {
	_, err := q.db.ExecContext(ctx, addEvent,
		arg.Tag,
		arg.Name,
		arg.Available,
		arg.Capacity,
		arg.Frontends,
		arg.Status,
		arg.Exercises,
		arg.StartedAt,
		arg.FinishExpected,
		arg.FinishedAt,
		arg.Createdby,
		arg.Onlyvpn,
		arg.Secretkey,
		arg.Disabledexercises,
	)
	return err
}

const addOrganization = `-- name: AddOrganization :exec
INSERT INTO Organizations (name, owner_user, owner_email) VALUES ($1, $2, $3)
`

type AddOrganizationParams struct {
	Org           string `json:"org"`
	Ownerusername string `json:"ownerusername"`
	Owneremail    string `json:"owneremail"`
}

func (q *Queries) AddOrganization(ctx context.Context, arg AddOrganizationParams) error {
	_, err := q.db.ExecContext(ctx, addOrganization, arg.Org, arg.Ownerusername, arg.Owneremail)
	return err
}

const addProfile = `-- name: AddProfile :exec
INSERT INTO profiles (name, secret, challenges) VALUES ($1, $2, $3)
`

type AddProfileParams struct {
	Name       string `json:"name"`
	Secret     bool   `json:"secret"`
	Challenges string `json:"challenges"`
}

func (q *Queries) AddProfile(ctx context.Context, arg AddProfileParams) error {
	_, err := q.db.ExecContext(ctx, addProfile, arg.Name, arg.Secret, arg.Challenges)
	return err
}

const addTeam = `-- name: AddTeam :exec
INSERT INTO team (tag, event_id, email, name, password, created_at, last_access, solved_challenges) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type AddTeamParams struct {
	Tag              string    `json:"tag"`
	EventID          int32     `json:"event_id"`
	Email            string    `json:"email"`
	Name             string    `json:"name"`
	Password         string    `json:"password"`
	CreatedAt        time.Time `json:"created_at"`
	LastAccess       time.Time `json:"last_access"`
	SolvedChallenges string    `json:"solved_challenges"`
}

func (q *Queries) AddTeam(ctx context.Context, arg AddTeamParams) error {
	_, err := q.db.ExecContext(ctx, addTeam,
		arg.Tag,
		arg.EventID,
		arg.Email,
		arg.Name,
		arg.Password,
		arg.CreatedAt,
		arg.LastAccess,
		arg.SolvedChallenges,
	)
	return err
}

const checkIfOrgExists = `-- name: CheckIfOrgExists :one
SELECT EXISTS( SELECT 1 FROM Organizations WHERE lower(name) = lower($1) )
`

func (q *Queries) CheckIfOrgExists(ctx context.Context, orgname string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfOrgExists, orgname)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkIfUserExists = `-- name: CheckIfUserExists :one
SELECT EXISTS( SELECT 1 FROM Admin_users WHERE lower(username) = lower($1) )
`

func (q *Queries) CheckIfUserExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkIfUserExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkProfileExists = `-- name: CheckProfileExists :one
SELECT EXISTS(SELECT 1 FROM profiles WHERE name = $1)
`

func (q *Queries) CheckProfileExists(ctx context.Context, name string) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProfileExists, name)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createAdminUser = `-- name: CreateAdminUser :exec
INSERT INTO Admin_users (username, password, full_name, email, role, organization) VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateAdminUserParams struct {
	Username     string `json:"username"`
	Password     string `json:"password"`
	FullName     string `json:"full_name"`
	Email        string `json:"email"`
	Role         string `json:"role"`
	Organization string `json:"organization"`
}

func (q *Queries) CreateAdminUser(ctx context.Context, arg CreateAdminUserParams) error {
	_, err := q.db.ExecContext(ctx, createAdminUser,
		arg.Username,
		arg.Password,
		arg.FullName,
		arg.Email,
		arg.Role,
		arg.Organization,
	)
	return err
}

const deleteAdminUser = `-- name: DeleteAdminUser :exec
DELETE FROM Admin_users WHERE LOWER(username)=LOWER($1)
`

func (q *Queries) DeleteAdminUser(ctx context.Context, lower string) error {
	_, err := q.db.ExecContext(ctx, deleteAdminUser, lower)
	return err
}

const deleteProfile = `-- name: DeleteProfile :exec
DELETE FROM profiles WHERE name = $1
`

func (q *Queries) DeleteProfile(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, deleteProfile, name)
	return err
}

const deleteTeam = `-- name: DeleteTeam :exec
DELETE FROM team WHERE tag=$1 and event_id = $2
`

type DeleteTeamParams struct {
	Tag     string `json:"tag"`
	EventID int32  `json:"event_id"`
}

func (q *Queries) DeleteTeam(ctx context.Context, arg DeleteTeamParams) error {
	_, err := q.db.ExecContext(ctx, deleteTeam, arg.Tag, arg.EventID)
	return err
}

const doesEventExist = `-- name: DoesEventExist :one
SELECT EXISTS (select tag from event where tag=$1 and status!=$2)
`

type DoesEventExistParams struct {
	Tag    string        `json:"tag"`
	Status sql.NullInt32 `json:"status"`
}

func (q *Queries) DoesEventExist(ctx context.Context, arg DoesEventExistParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, doesEventExist, arg.Tag, arg.Status)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const dropEvent = `-- name: DropEvent :exec
DELETE FROM event WHERE tag=$1 and status=$2
`

type DropEventParams struct {
	Tag    string        `json:"tag"`
	Status sql.NullInt32 `json:"status"`
}

func (q *Queries) DropEvent(ctx context.Context, arg DropEventParams) error {
	_, err := q.db.ExecContext(ctx, dropEvent, arg.Tag, arg.Status)
	return err
}

const earliestDate = `-- name: EarliestDate :one
SELECT started_at FROM event WHERE started_at=(SELECT MIN(started_at) FROM event) and finished_at = date('0001-01-01 00:00:00')
`

func (q *Queries) EarliestDate(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, earliestDate)
	var started_at time.Time
	err := row.Scan(&started_at)
	return started_at, err
}

const getAdminUser = `-- name: GetAdminUser :one
SELECT id, username, password, full_name, email, role, organization FROM Admin_users WHERE LOWER(username)=LOWER($1)
`

func (q *Queries) GetAdminUser(ctx context.Context, username string) (AdminUser, error) {
	row := q.db.QueryRowContext(ctx, getAdminUser, username)
	var i AdminUser
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.FullName,
		&i.Email,
		&i.Role,
		&i.Organization,
	)
	return i, err
}

const getAdminUserNoPw = `-- name: GetAdminUserNoPw :one
SELECT username, full_name, email, role, organization FROM Admin_users WHERE LOWER(username)=LOWER($1)
`

type GetAdminUserNoPwRow struct {
	Username     string `json:"username"`
	FullName     string `json:"full_name"`
	Email        string `json:"email"`
	Role         string `json:"role"`
	Organization string `json:"organization"`
}

func (q *Queries) GetAdminUserNoPw(ctx context.Context, lower string) (GetAdminUserNoPwRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminUserNoPw, lower)
	var i GetAdminUserNoPwRow
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.Role,
		&i.Organization,
	)
	return i, err
}

const getAdminUsers = `-- name: GetAdminUsers :many
SELECT username, full_name, email, role, organization FROM Admin_users WHERE organization = CASE WHEN $1='' THEN organization ELSE $1 END
`

type GetAdminUsersRow struct {
	Username     string `json:"username"`
	FullName     string `json:"full_name"`
	Email        string `json:"email"`
	Role         string `json:"role"`
	Organization string `json:"organization"`
}

func (q *Queries) GetAdminUsers(ctx context.Context, organization interface{}) ([]GetAdminUsersRow, error) {
	rows, err := q.db.QueryContext(ctx, getAdminUsers, organization)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAdminUsersRow
	for rows.Next() {
		var i GetAdminUsersRow
		if err := rows.Scan(
			&i.Username,
			&i.FullName,
			&i.Email,
			&i.Role,
			&i.Organization,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllEvents = `-- name: GetAllEvents :many
SELECT id, tag, name, available, capacity, status, frontends, exercises, started_at, finish_expected, finished_at, createdby, onlyvpn, secretkey, disabledexercises FROM event
`

func (q *Queries) GetAllEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getAllEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.Name,
			&i.Available,
			&i.Capacity,
			&i.Status,
			&i.Frontends,
			&i.Exercises,
			&i.StartedAt,
			&i.FinishExpected,
			&i.FinishedAt,
			&i.Createdby,
			&i.Onlyvpn,
			&i.Secretkey,
			&i.Disabledexercises,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableEvents = `-- name: GetAvailableEvents :many
SELECT id FROM event WHERE tag=$1 and finished_at = date('0001-01-01 00:00:00') and (status = 0 or status = 1 or status = 2)
`

func (q *Queries) GetAvailableEvents(ctx context.Context, tag string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableEvents, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var id int32
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventStatus = `-- name: GetEventStatus :many
SELECT status FROM event WHERE tag=$1
`

func (q *Queries) GetEventStatus(ctx context.Context, tag string) ([]sql.NullInt32, error) {
	rows, err := q.db.QueryContext(ctx, getEventStatus, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullInt32
	for rows.Next() {
		var status sql.NullInt32
		if err := rows.Scan(&status); err != nil {
			return nil, err
		}
		items = append(items, status)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByStatus = `-- name: GetEventsByStatus :many
SELECT id, tag, name, available, capacity, status, frontends, exercises, started_at, finish_expected, finished_at, createdby, onlyvpn, secretkey, disabledexercises FROM event WHERE status=$1
`

func (q *Queries) GetEventsByStatus(ctx context.Context, status sql.NullInt32) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.Name,
			&i.Available,
			&i.Capacity,
			&i.Status,
			&i.Frontends,
			&i.Exercises,
			&i.StartedAt,
			&i.FinishExpected,
			&i.FinishedAt,
			&i.Createdby,
			&i.Onlyvpn,
			&i.Secretkey,
			&i.Disabledexercises,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByUser = `-- name: GetEventsByUser :many
SELECT id, tag, name, available, capacity, status, frontends, exercises, started_at, finish_expected, finished_at, createdby, onlyvpn, secretkey, disabledexercises FROM event WHERE status!=$1 and createdby=$2
`

type GetEventsByUserParams struct {
	Status    sql.NullInt32 `json:"status"`
	Createdby string        `json:"createdby"`
}

func (q *Queries) GetEventsByUser(ctx context.Context, arg GetEventsByUserParams) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsByUser, arg.Status, arg.Createdby)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.Name,
			&i.Available,
			&i.Capacity,
			&i.Status,
			&i.Frontends,
			&i.Exercises,
			&i.StartedAt,
			&i.FinishExpected,
			&i.FinishedAt,
			&i.Createdby,
			&i.Onlyvpn,
			&i.Secretkey,
			&i.Disabledexercises,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsExeptClosed = `-- name: GetEventsExeptClosed :many
SELECT id, tag, name, available, capacity, status, frontends, exercises, started_at, finish_expected, finished_at, createdby, onlyvpn, secretkey, disabledexercises FROM event WHERE status!=3
`

func (q *Queries) GetEventsExeptClosed(ctx context.Context) ([]Event, error) {
	rows, err := q.db.QueryContext(ctx, getEventsExeptClosed)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.Name,
			&i.Available,
			&i.Capacity,
			&i.Status,
			&i.Frontends,
			&i.Exercises,
			&i.StartedAt,
			&i.FinishExpected,
			&i.FinishedAt,
			&i.Createdby,
			&i.Onlyvpn,
			&i.Secretkey,
			&i.Disabledexercises,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExerciseDatabases = `-- name: GetExerciseDatabases :many
SELECT id, name, organization, url, sign_key, auth_key FROM Exercise_dbs
`

func (q *Queries) GetExerciseDatabases(ctx context.Context) ([]ExerciseDb, error) {
	rows, err := q.db.QueryContext(ctx, getExerciseDatabases)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExerciseDb
	for rows.Next() {
		var i ExerciseDb
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Organization,
			&i.Url,
			&i.SignKey,
			&i.AuthKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrgByName = `-- name: GetOrgByName :one
SELECT id, name, owner_user, owner_email FROM Organizations WHERE LOWER(name)=LOWER($1)
`

func (q *Queries) GetOrgByName(ctx context.Context, orgname string) (Organization, error) {
	row := q.db.QueryRowContext(ctx, getOrgByName, orgname)
	var i Organization
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.OwnerUser,
		&i.OwnerEmail,
	)
	return i, err
}

const getProfiles = `-- name: GetProfiles :many
SELECT id, name, secret, organization, challenges FROM profiles ORDER BY id asc
`

func (q *Queries) GetProfiles(ctx context.Context) ([]Profile, error) {
	rows, err := q.db.QueryContext(ctx, getProfiles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Profile
	for rows.Next() {
		var i Profile
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Secret,
			&i.Organization,
			&i.Challenges,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamCount = `-- name: GetTeamCount :many
SELECT count(team.id) FROM team WHERE team.event_id=$1
`

func (q *Queries) GetTeamCount(ctx context.Context, eventID int32) ([]int64, error) {
	rows, err := q.db.QueryContext(ctx, getTeamCount, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int64
	for rows.Next() {
		var count int64
		if err := rows.Scan(&count); err != nil {
			return nil, err
		}
		items = append(items, count)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamsForEvent = `-- name: GetTeamsForEvent :many
SELECT id, tag, event_id, email, name, password, created_at, last_access, solved_challenges FROM team WHERE event_id=$1
`

func (q *Queries) GetTeamsForEvent(ctx context.Context, eventID int32) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, getTeamsForEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.ID,
			&i.Tag,
			&i.EventID,
			&i.Email,
			&i.Name,
			&i.Password,
			&i.CreatedAt,
			&i.LastAccess,
			&i.SolvedChallenges,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const latestDate = `-- name: LatestDate :one
SELECT finish_expected FROM event WHERE finish_expected =(SELECT max(finish_expected) FROM event) and finished_at = date('0001-01-01 00:00:00')
`

func (q *Queries) LatestDate(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, latestDate)
	var finish_expected time.Time
	err := row.Scan(&finish_expected)
	return finish_expected, err
}

const teamSolvedChls = `-- name: TeamSolvedChls :many
SELECT solved_challenges FROM team WHERE tag=$1
`

func (q *Queries) TeamSolvedChls(ctx context.Context, tag string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, teamSolvedChls, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var solved_challenges string
		if err := rows.Scan(&solved_challenges); err != nil {
			return nil, err
		}
		items = append(items, solved_challenges)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAdminEmail = `-- name: UpdateAdminEmail :exec
UPDATE Admin_users SET email = $1 WHERE username = $2
`

type UpdateAdminEmailParams struct {
	Email    string `json:"email"`
	Username string `json:"username"`
}

func (q *Queries) UpdateAdminEmail(ctx context.Context, arg UpdateAdminEmailParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminEmail, arg.Email, arg.Username)
	return err
}

const updateAdminPassword = `-- name: UpdateAdminPassword :exec
UPDATE Admin_users SET password = $1 WHERE username = $2
`

type UpdateAdminPasswordParams struct {
	Password string `json:"password"`
	Username string `json:"username"`
}

func (q *Queries) UpdateAdminPassword(ctx context.Context, arg UpdateAdminPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateAdminPassword, arg.Password, arg.Username)
	return err
}

const updateCloseEvent = `-- name: UpdateCloseEvent :exec
UPDATE event SET tag = $2, finished_at = $3 WHERE tag = $1
`

type UpdateCloseEventParams struct {
	Tag        string    `json:"tag"`
	Tag_2      string    `json:"tag_2"`
	FinishedAt time.Time `json:"finished_at"`
}

func (q *Queries) UpdateCloseEvent(ctx context.Context, arg UpdateCloseEventParams) error {
	_, err := q.db.ExecContext(ctx, updateCloseEvent, arg.Tag, arg.Tag_2, arg.FinishedAt)
	return err
}

const updateEventStatus = `-- name: UpdateEventStatus :exec
UPDATE event SET status = $2 WHERE tag = $1
`

type UpdateEventStatusParams struct {
	Tag    string        `json:"tag"`
	Status sql.NullInt32 `json:"status"`
}

func (q *Queries) UpdateEventStatus(ctx context.Context, arg UpdateEventStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateEventStatus, arg.Tag, arg.Status)
	return err
}

const updateExercises = `-- name: UpdateExercises :exec

UPDATE team SET last_access = $2 WHERE tag = $1
`

type UpdateExercisesParams struct {
	Tag        string    `json:"tag"`
	LastAccess time.Time `json:"last_access"`
}

// UPDATE event SET exercises = (SELECT (SELECT exercises FROM event WHERE id = $1) || $2) WHERE id=$1;
func (q *Queries) UpdateExercises(ctx context.Context, arg UpdateExercisesParams) error {
	_, err := q.db.ExecContext(ctx, updateExercises, arg.Tag, arg.LastAccess)
	return err
}

const updateProfile = `-- name: UpdateProfile :exec
UPDATE profiles SET secret = $1, challenges = $2 WHERE name = $3
`

type UpdateProfileParams struct {
	Secret     bool   `json:"secret"`
	Challenges string `json:"challenges"`
	Name       string `json:"name"`
}

func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) error {
	_, err := q.db.ExecContext(ctx, updateProfile, arg.Secret, arg.Challenges, arg.Name)
	return err
}

const updateTeamPassword = `-- name: UpdateTeamPassword :exec
UPDATE team SET password = $1 WHERE tag = $2 and event_id = $3
`

type UpdateTeamPasswordParams struct {
	Password string `json:"password"`
	Tag      string `json:"tag"`
	EventID  int32  `json:"event_id"`
}

func (q *Queries) UpdateTeamPassword(ctx context.Context, arg UpdateTeamPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateTeamPassword, arg.Password, arg.Tag, arg.EventID)
	return err
}

const updateTeamSolvedChl = `-- name: UpdateTeamSolvedChl :exec
UPDATE team SET solved_challenges = $2 WHERE tag = $1
`

type UpdateTeamSolvedChlParams struct {
	Tag              string `json:"tag"`
	SolvedChallenges string `json:"solved_challenges"`
}

func (q *Queries) UpdateTeamSolvedChl(ctx context.Context, arg UpdateTeamSolvedChlParams) error {
	_, err := q.db.ExecContext(ctx, updateTeamSolvedChl, arg.Tag, arg.SolvedChallenges)
	return err
}
